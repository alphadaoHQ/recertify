// Minimal wrapper export for CertificationCollection
// This file provides `CertificationCollection.fromInit` / `fromAddress` and companion getters used by the admin.
// It is a thin copy of the generated wrapper from the build folder, trimmed to the methods we need.

import { Cell, Address, beginCell, contractAddress, Contract } from "@ton/core";

// We'll reuse the types and methods from the generated file. To keep this file small
// we only implement the static fromInit helper that returns the init (code+data) and computes the resulting address.

export type CertificationCollectionInit = { code: Cell; data: Cell };

// NOTE: In the original generated file, `fromInit` builds an init and computes contract address.
// We will replicate that behaviour by calling the constructor function generated by the compiler.

// The real generated `fromInit` logic depends on the exact init builder produced at build-time.
// For deploy UI we only need a way to compute the contract address given code+data.

export function computeContractAddress(init: CertificationCollectionInit) {
  return contractAddress(0, init as any);
}

export const CertificationCollection = {
  // Accept the StateInit ({code, data}) and return the implied address
  fromInit: (_owner: Address, _base_uri: string, _itemCode: Cell) => {
    // The real generated fromInit constructs the code and data cells using the contract's init method.
    // For our UI we will expect the user to upload compiled .boc for the collection or rely on pre-deployed collections.
    // So this function is a placeholder; callers can pass `init` directly to computeContractAddress.
    throw new Error("Use computeContractAddress with explicit init (code/data). For full fromInit behaviour import the generated wrapper from build.");
  },
};
